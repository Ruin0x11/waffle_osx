/*=======================================================================
  AVG32-like scriptor for Macintosh
  Copyright 2000, K.Takagi(Kenjo)

  cgmfile.h
    CGモードデータ（MODE.CGM）管理用のクラス
=======================================================================*/

#include <stdio.h>
#include <string.h>

#include "cgmfile.h"
#include "system.h"
#include "flags.h"
#include "debug.h"
#include "common.h"

// なんか暗号化されてるね・・・
// ってことで解読キー。どのゲームでも共通っぽい。
static const unsigned char cgmkey[256] = {
	0x8b, 0xe5, 0x5d, 0xc3, 0xa1, 0xe0, 0x30, 0x44, 0x00, 0x85, 0xc0, 0x74, 0x09, 0x5f, 0x5e, 0x33,
	0xc0, 0x5b, 0x8b, 0xe5, 0x5d, 0xc3, 0x8b, 0x45, 0x0c, 0x85, 0xc0, 0x75, 0x14, 0x8b, 0x55, 0xec,
	0x83, 0xc2, 0x20, 0x52, 0x6a, 0x00, 0xe8, 0xf5, 0x28, 0x01, 0x00, 0x83, 0xc4, 0x08, 0x89, 0x45,
	0x0c, 0x8b, 0x45, 0xe4, 0x6a, 0x00, 0x6a, 0x00, 0x50, 0x53, 0xff, 0x15, 0x34, 0xb1, 0x43, 0x00,
	0x8b, 0x45, 0x10, 0x85, 0xc0, 0x74, 0x05, 0x8b, 0x4d, 0xec, 0x89, 0x08, 0x8a, 0x45, 0xf0, 0x84,
	0xc0, 0x75, 0x78, 0xa1, 0xe0, 0x30, 0x44, 0x00, 0x8b, 0x7d, 0xe8, 0x8b, 0x75, 0x0c, 0x85, 0xc0,
	0x75, 0x44, 0x8b, 0x1d, 0xd0, 0xb0, 0x43, 0x00, 0x85, 0xff, 0x76, 0x37, 0x81, 0xff, 0x00, 0x00,
	0x04, 0x00, 0x6a, 0x00, 0x76, 0x43, 0x8b, 0x45, 0xf8, 0x8d, 0x55, 0xfc, 0x52, 0x68, 0x00, 0x00,
	0x04, 0x00, 0x56, 0x50, 0xff, 0x15, 0x2c, 0xb1, 0x43, 0x00, 0x6a, 0x05, 0xff, 0xd3, 0xa1, 0xe0,
	0x30, 0x44, 0x00, 0x81, 0xef, 0x00, 0x00, 0x04, 0x00, 0x81, 0xc6, 0x00, 0x00, 0x04, 0x00, 0x85,
	0xc0, 0x74, 0xc5, 0x8b, 0x5d, 0xf8, 0x53, 0xe8, 0xf4, 0xfb, 0xff, 0xff, 0x8b, 0x45, 0x0c, 0x83,
	0xc4, 0x04, 0x5f, 0x5e, 0x5b, 0x8b, 0xe5, 0x5d, 0xc3, 0x8b, 0x55, 0xf8, 0x8d, 0x4d, 0xfc, 0x51,
	0x57, 0x56, 0x52, 0xff, 0x15, 0x2c, 0xb1, 0x43, 0x00, 0xeb, 0xd8, 0x8b, 0x45, 0xe8, 0x83, 0xc0,
	0x20, 0x50, 0x6a, 0x00, 0xe8, 0x47, 0x28, 0x01, 0x00, 0x8b, 0x7d, 0xe8, 0x89, 0x45, 0xf4, 0x8b,
	0xf0, 0xa1, 0xe0, 0x30, 0x44, 0x00, 0x83, 0xc4, 0x08, 0x85, 0xc0, 0x75, 0x56, 0x8b, 0x1d, 0xd0,
	0xb0, 0x43, 0x00, 0x85, 0xff, 0x76, 0x49, 0x81, 0xff, 0x00, 0x00, 0x04, 0x00, 0x6a, 0x00, 0x76
};

/************************************************************************
  class NOVELFONT
************************************************************************/

// こんすとらくた
CGMODE::CGMODE(SYSTEM* s, FLAGS* flg)
{
	int filesize, i;
	unsigned char* tmpbuf;
	unsigned char* buf;

	sys = s;
	flags = flg;
	for (i=0; i<MAXCG; i++)	memset(file[i], 0, 32);

	buf = 0;
	cgnum = 0;

	tmpbuf = sys->ReadFile("MODE.CGM", "OTH", &filesize);

	if ( tmpbuf ) {
		cgnum = (tmpbuf[16]|(tmpbuf[17]<<8)|(tmpbuf[18]<<16)|(tmpbuf[19]<<24));
		// 暗号化解除
		for ( i=0; i<(filesize-32); i++ ) {
			tmpbuf[i+32] ^= cgmkey[i&255];
		}
		// PACKファイルが出てくるので、Unpackする
		buf = sys->Unpack(tmpbuf+32, &filesize);
		delete[] tmpbuf;
	}
	// ファイル名(32byte)＋対応フラグ番号(Int)が並ぶ構造
	if ( buf ) {
/*{
FILE* fp;
fp = fopen("_cgmode.log","a");
fprintf(fp, "Total CG : #%d¥n", cgnum);
fclose(fp);
}*/
		for (i=0; i<cgnum; i++) {
			memcpy(file[i], &buf[i*36], 32);
			flagbit[i] = (buf[i*36+32]|(buf[i*36+33]<<8)|(buf[i*36+34]<<16)|(buf[i*36+35]<<24));
/*{
FILE* fp;
fp = fopen("_cgmode.log","a");
fprintf(fp, "  %s - Bit[%d]¥n", file[i], flagbit[i]);
fclose(fp);
}*/
		}
		delete[] buf;
	}
};


// ですとらくた
CGMODE::‾CGMODE(void)
{
};


// ファイル名の画像がCGM中にあれば、対応ビットをたてる
void CGMODE::SetFlag(char* f)
{
	int i;
	for (i=0; i<cgnum; i++) {
		if ( !strcmp((char*)file[i], f) ) {
			flags->SetBit(flagbit[i], 1);
/*{
FILE* fp;
fp = fopen("_cgmode.log","a");
fprintf(fp, "  %s - Set Bit[%d]¥n", f, flagbit[i]);
fclose(fp);
}*/
			break;
		}
	}
}


// 達成率を返す
int CGMODE::GetPercentage(void)
{
	int i, count, ret;
	count = 0;
	for (i=0; i<cgnum; i++) {
		if ( flags->GetBit(flagbit[i]) ) count++;
	}
	if ( cgnum ) ret = ((count*100)/cgnum);
	return ret;
}


// CGM中のn番目の画像を見たかどうかを返す
int CGMODE::GetFlag(int n)
{
	int ret = 0;
	if ( (n>=0)&&(n<cgnum) ) {
		if ( flags->GetBit(flagbit[n]) ) ret = 1;
	}
	return ret;
}


// CGMに登録されている総CG数を返す
int CGMODE::GetCGAllNum(void)
{
	return cgnum;
}


// これまでに見たCG数を返す
int CGMODE::GetCGNum(void)
{
	int i;
	int ret = 0;
	for (i=0; i<cgnum; i++) {
		if ( flags->GetBit(flagbit[i]) ) ret++;
	}
	return ret;
}


// CGM中のn番目のCGファイル名を返す
char* CGMODE::GetCGName(int n)
{
	char* ret = 0;
	if ( (n>=0)&&(n<cgnum) ) {
		ret = (char*)file[n];
	}
	return ret;
}


// n番目のCGに対応するフラグ番号を返す
int CGMODE::GetCGFlagNum(int n)
{
	int ret = 0;
	if ( (n>=0)&&(n<cgnum) ) {
		ret = flagbit[n];
	}
	return ret;
}
